### Computational Thinking....

**builds on the power and limits of computing processes, whether they are executed by a human or by a machine.**

**confronts the riddle of machine intelligence: What can humans do better than computers? and What can computers do better than humans? Most fundamentally it addresses the question: What is computable?**

**is a fundamental skill for everyone, not just for computer scientists.**

involves solving problems, designing systems, and understanding human behavior, by drawing on the concepts fundamental to computer science.

includes a range of mental tools that reflect the breadth of the field of computer science.

is reformulating a seemingly difficult problem into one we know how to solve, perhaps by reduction, embedding, transformation, or simulation.

is thinking recursively.

is parallel processing.

is interpreting code as data and data as code.

is type checking as the generalization of dimensional analysis.

is recognizing both the virtues and the dangers of aliasing, or giving someone or something more than one name.

is recognizing both the cost and power of indirect addressing and procedure call.

**is judging a program not just for correctness and efficiency but for aesthetics, and a system’s design for simplicity and elegance.**

is using abstraction and decomposition when attacking a large complex task or designing a large complex system.

is separation of concerns.

is choosing an appropriate representation for a problem or modeling the relevant aspects of a problem to make it tractable.

is using invariants to describe a system’s behavior succinctly and declaratively.

**is having the confidence we can safely use, modify, and influence a large complex system without understanding its every detail.**

is modularizing something in anticipation of multiple users or prefetching and caching in anticipation of future use.

is thinking in terms of prevention, protection, and recovery from worst-case scenarios through redundancy, damage containment, and error correction.

is calling gridlock deadlock and contracts interfaces.

is learning to avoid race conditions when synchronizing meetings with one another.

is using heuristic reasoning to discover a solution.

is planning, learning, and scheduling in the presence of uncertainty.

is search, search, and more search, resulting in a list of Web pages, a strategy for winning a game, or a counterexample.

is using massive amounts of data to speed up computation.

is making trade-offs between time and space and between processing power and storage capacity.

**is a grand vision to guide computer science educators, researchers, and practitioners as we act to change society’s image of the field.**
